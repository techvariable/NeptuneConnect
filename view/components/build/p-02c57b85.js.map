{"version":3,"sources":["src/utils/utils.ts"],"names":["permissionsKeys","isValidPermissionJson","jsonData","data","JSON","parse","keys","Object","length","Error","forEach","item","includes","join","permission","undefined","allPermission","key","e","isValid","error","message","isValidParameterJson","query","pattern","queryParameters","match","Array","isArray","value","split","pop","console","log","formatJSON","json","stringify","hasAccess","permissions","route","find","v","some","name","combinePermissions","supportedKeys","updatedPermissions","k","read","write","delete","update","permissionKeys","jsonToCsv","jsonContent","Set","row","add","columns","map"],"mappings":"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","sourcesContent":["export const permissionsKeys: string[] = ['editor', 'settings', 'permissions', 'users', 'logs', 'profile', '*'];\n\nexport function format(first: string, middle: string, last: string): string {\n  return (first || '') + (middle ? ` ${middle}` : '') + (last ? ` ${last}` : '');\n}\n\nexport function isValidPermissionJson(jsonData: string) {\n  try {\n    const data: any = JSON.parse(jsonData);\n    const keys: string[] = Object.keys(data);\n    if (keys.length === 0) {\n      throw Error('No keys present in the json');\n    }\n    keys.forEach((item: string) => {\n      if (!permissionsKeys.includes(item)) {\n        throw Error(`${item} key is not a valid permission key. Following are the valid permissions: ${permissionsKeys.join(', ')}.`);\n      }\n      const permission = data[item];\n\n      if (permission['*'] == undefined) {\n        let allPermission = ['read', 'write', 'delete', 'update'];\n        for (let key of allPermission) {\n          if (permission[key] === undefined) throw Error(`${key} property not present in ${item}`);\n        }\n      }\n    });\n  } catch (e) {\n    return {\n      isValid: false,\n      error: e.message,\n    };\n  }\n  return {\n    isValid: true,\n    error: null,\n  };\n}\n\nexport function isValidParameterJson(query: string, jsonData: string) {\n  const pattern = /(:[a-zA-Z])\\w+/g;\n  const queryParameters: string[] = query.match(pattern);\n\n  try {\n    if (Array.isArray(queryParameters)) {\n      const data: any = JSON.parse(jsonData);\n\n      const keys: string[] = Object.keys(data);\n      queryParameters.forEach((item: string) => {\n        let value = item.split(':').pop();\n        if (!keys.includes(value)) {\n          throw Error(`${value} key not present in the json`);\n        }\n      });\n    }\n  } catch (e) {\n    console.log(e);\n    return {\n      isValid: false,\n      error: e.message,\n    };\n  }\n  return {\n    isValid: true,\n    error: null,\n  };\n}\n\nexport function formatJSON(json: object): string {\n  return JSON.stringify(json, undefined, 4);\n}\nexport function hasAccess(permissions: any[], route: { name: string | string[]; permission: 'read' | 'write' | 'delete' | 'update' }): boolean {\n  if (\n    !(\n      permissions.find(v => '*' in v && v['*']['*']) != null ||\n      permissions.find(v => '*' in v && v['*'][route.permission]) != null ||\n      permissions.some(v => {\n        if (!Array.isArray(route.name)) {\n          return route.name in v && v[route.name][route.permission];\n        } else {\n          return route.name.some(name => name in v && v[name][route.permission]);\n        }\n      })\n    )\n  ) {\n    return false;\n  }\n  return true;\n}\n\nexport function combinePermissions(permissions: any[]): any[] {\n  const supportedKeys: string[] = ['editor', 'settings', 'permissions', 'users', 'logs', 'profile', '*'];\n  const updatedPermissions = {};\n\n  supportedKeys.forEach(k => {\n    updatedPermissions[k] = {\n      read: false,\n      write: false,\n      delete: false,\n      update: false,\n    };\n  });\n\n  permissions.forEach(permission => {\n    const permissionKeys = Object.keys(permission);\n    permissionKeys.forEach(key => {\n      if (key === '*') {\n        supportedKeys.forEach(k => {\n          if (permission[key]['*'] !== undefined) {\n            updatedPermissions[k] = {\n              read: permission[key]['*'],\n              write: permission[key]['*'],\n              update: permission[key]['*'],\n              delete: permission[key]['*'],\n            };\n          } else {\n            updatedPermissions[k] = {\n              read: hasAccess(permissions, { name: key, permission: 'read' }),\n              write: hasAccess(permissions, { name: key, permission: 'write' }),\n              update: hasAccess(permissions, { name: key, permission: 'update' }),\n              delete: hasAccess(permissions, { name: key, permission: 'delete' }),\n            };\n          }\n        });\n      } else {\n        if (permission[key]['*'] !== undefined) {\n          updatedPermissions[key] = {\n            read: permission[key]['*'],\n            write: permission[key]['*'],\n            update: permission[key]['*'],\n            delete: permission[key]['*'],\n          };\n        } else {\n          updatedPermissions[key] = {\n            read: hasAccess(permissions, { name: key, permission: 'read' }),\n            write: hasAccess(permissions, { name: key, permission: 'write' }),\n            update: hasAccess(permissions, { name: key, permission: 'update' }),\n            delete: hasAccess(permissions, { name: key, permission: 'delete' }),\n          };\n        }\n      }\n    });\n  });\n  delete updatedPermissions['*'];\n  // @ts-expect-error\n  return updatedPermissions;\n}\n\nexport function jsonToCsv<T extends {}>(jsonContent: Array<T>): { columns: string[]; data: Array<Array<T>> } {\n  const keys = new Set<string>();\n\n  jsonContent.forEach(row => {\n    Object.keys(row).forEach(k => {\n      keys.add(k);\n    });\n  });\n\n  return {\n    columns: [...keys],\n    data: jsonContent.map(row => {\n      return [...keys].map(k => row[k] || '');\n    }),\n  };\n}\n"]}